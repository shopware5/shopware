<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>HowTo: SW4 Backend Modul erstellen</title>
		<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
		
		<link rel="stylesheet" href="css/bootstrap.css" />
		<link rel="stylesheet" href="css/style.css" />
		<link rel="stylesheet" href="css/prettify.css" />
		
		<style>
		figcaption { display: block; text-align: center; font-style: italic; }
		.space { height: 15px; }
		</style>
	</head>
	<body>
		
		<nav class="topbar" data-scrollspy="scrollspy">
			<div class="fill">
				<div class="container">
					<h3><a href="#">HowTo: SW4 Backend Modul</a></h3>
					
					<ul>
						<li>
							<a href="#folderstructure">Ordnerstruktur</a>
						</li>
						<li>
							<a href="#subappstarter">Applikationstarter</a>
						</li>
						<li>
							<a href="#controller">Controller</a>
						</li>
						<li>
							<a href="#model">Model</a>
						</li>
						<li>
							<a href="#store">Store</a>
						</li>
						<li>
							<a href="#view">View</a>
						</li>
						<li>
							<a href="#events">Events</a>
						</li>
						<li>
							<a href="#pitfalls">Pitfalls</a>
						</li>
					</ul>
				</div>
			</div>
		</nav>
		
		<!-- Container -->	
		<div class="container">
		
			<!-- Intro -->
			<section id="intro">

				<div class="page-header">
					<h2>Einf&uuml;hrung</h2>
				</div>
				
					<div class="row">
						<div class="span16">
							<p>
								Im folgenden Tutorial werden wir die einzelnen Schritte zur Erstellung eines neuen Backend-Modul erlernen. Vorweg sollte man aber wissen das jedes Modul eine sogenannte Subapplikation darstellt und vollkommen unabh&auml;ngig von anderen Modulen ist. Dies hat den Vorteil dass das Modul wesentlich modularer als bisher aufgebaut werden kann und wir das Lazy Loading einzelner Module verwenden k&ouml;nnen, was einen Geschwindigkeitsgewinn f&uuml;r den Benutzer bedeutet.
							</p>
							
							<div class="space"></div>
							
							<p>
								Falls Ihr euch noch nicht mit ExtJS 4 besch&auml;ftigt habt, dann schaut euch bitte die folgenden Links an:
							</p>
							
							<ul>
								<li>
									<a href="http://docs.sencha.com/ext-js/4-0/#!/guide/application_architecture" target="_blank">
										MVC Architecture
									</a>
								</li>
								<li>
									<a href="http://docs.sencha.com/ext-js/4-0/#!/guide/class_system" target="_blank">
										Class System
									</a>
								</li>
								<li>
									<a href="http://www.sencha.com/blog/ext-js-3-to-4-migration" target="_blank">
										Ext JS 3 to 4 Migration
									</a>
								</li>
								<li>
									<a href="http://www.sencha.com/learn/debugging-ext-js-applications/" target="_blank">
										Debugging Ext JS applications
									</a>
								</li>
								<li>
									<a href="http://www.sencha.com/blog/sencha-basics-an-introduction-to-data-stores/" target="_blank">
										Sencha Basics: An Introduction to Data Stores
									</a>
								</li>
							</ul>
						</div>
					</div>
			
				</section>  <!-- //Intro-->
				
				<!-- Folder structure -->
				<section id="folderstructure">
					<div class="page-header">
						<h2>1. Ordnerstruktur erstellen</h2>
					</div>
				
					<div class="row">
						<div class="span16">
						
						<p>
							Als Erstes starten wir, wie sollte es auch anders sein, mit der grundlegenden Ordnerstruktur eines Moduls. Die Templates werden jeweils im Verzeichnis <code>"/templates/_default/backend"</code> angelegt. Damit das Lazy Loading korrekt funktioniert und wir am Ende der Entwicklung eine Bulk-Verarbeitung von Modulen einbauen k&ouml;nnen muss diese Struktur eingehalten werden.
						</p>
<pre class="prettyprint lang-js">/
  /controller
  /model
  /store
  /view
  app.js - Initialisiert die SubApplikation</pre>
						</div>
					</div>
				</section>  <!-- //Folder structure-->
				
				<!-- SubAppStarter -->
				<section id="subappstarter">
					<div class="page-header">
						<h2>2. app.js - Der Applikationsstarter</h2>
					</div>
				
					<div class="row">
						<div class="span16">
							<p>
								Wie Ihr in der Ordnerstruktur seht befindet sich in jeden Ordner eines Moduls eine <code>"app.js"</code>, welche als Starter f&uuml;r unser Modul bzw. besser gesagt unser Sub-Applikation fungiert. Hier werden die verschiedenen Controller unserer Applikation geladen und der Pfad zum Modul angegeben. Gehen wir davon aus, dass das Modul, welches wir erstellen m&ouml;chten unter dem Namespace <code>"Shopware.apps.Auth"</code> l&auml;ft sieht eine typische <code>"app.js"</code> wie folgt aus:
							</p>
							
<pre class="prettyprint lang-js linenums">Ext.define('Shopware.apps.Auth', {

   /**
    * The name of the module. Used for internal purpose
    * @string
    */
   name: 'Shopware.apps.Auth',

   /**
    * Extends from our special controller, which handles the 
    * sub-application behavior and the event bus
    * @string
    */
   extend: 'Enlight.app.SubApplication',
   
   /**
    * Sets the loading path for the sub-application.
    *
    * Note that you'll need a "loadAction" in your 
    * controller (server-side)
    * @string
    */
   loadPath: "{url action=load}?file=",
   
   /**
    * Requires controllers for sub-application
    * @array
    */
   controllers: [ 'Main' ]
});</pre>

							<p>
								Bitte beachtet, dass die URLs &uuml;ber das Smarty-Plugin <code>"{url}"</code> zusammengesetzt werden. N&auml;here Informationen rund um das URL-Plugin sind in der <a href="http://wiki.shopware.de/_detail_544.html#url_-_Plugin" target="_blank">Templatedokumentation von Shopware 3.5</a> verf&uuml;bar.
							</p>

							<p>
								In diesen Fall hat unsere Sub-Applikation nur einen Controller mit den Namen <code>"Main"</code> (kompletter Namespace: <code>Shopware.apps.Auth.controller.Main</code>), welcher die komplette Business Logik der Sub-Applikation beinhaltet.
							</p>
							
							<p>
								Es besteht zudem die M&ouml;glichkeit bei der Initialisierung der Sub-Applikationen &uuml;ber eine <code>"launch"</code>-Methode z.B. weitere Konfigurationen vorzunehmen.
							</p>

<pre class="prettyprint lang-js linenums">/**
 * Will be called when the sub-application is launched
 * @return void
 */
launch: function() {
   this.callParent(arguments);
   
   console.log(this.$className + ' has launched !!!');   //Outputs: Shopware.apps.Auth has launched !!!
}</pre>
						</div>
					</div>
				</section>  <!-- //SubAppStarter-->
				
				<!-- Controller -->
				<section id="controller">
					<div class="page-header">
						<h2>3. Unser erster Controller</h2>
					</div>
				
					<div class="row">
						<div class="span16">
							<p>
								Wie man bereits in der <code>"app.js"</code> sehen kann arbeitet die Sub-Applikation aktuell nur mit einen Controller namens <code>"Main"</code>, welchen wir im folgenden anlegen und in seine Einzelteile zerlegen. Beim Anlegen einer beliebigen Datei ist <strong>immer</strong> darauf zu achten dass diese in "lowercase" geschrieben wird. Um jetzt mit den Controller zu starten, legen wir im Verzeichnis <code>"controller"</code> eine Datei mit den Namen <code>"main.js"</code> an.
							</p>
							
							<p>
								Als N&auml;chstes implementieren wir die Grundstruktur eines jeden Controllers:
							</p>

<pre class="prettyprint lang-js linenums">Ext.define('Shopware.apps.Auth.controller.Main', {

   /**
    * Extend from the standard ExtJS 4  <a href="http://docs.sencha.com/ext-js/4-0/#!/api/Ext.app.Controller" target="_blank">{@link Ext.app.Controller}</a>
    * @string
    */
   extend: 'Ext.app.Controller',
   
   /**
    * Required views for controller
    * @array
    */
   //views: [ 'main.List' ],
   
   /**
    * Required stores for controller
    * @array
    */
   //stores: [ 'Main' ],
   
   /**
    * Required models for controller
    * @array
    */
   //models: [ 'Main' ]
   
   /**
    * Creates the necessary event listener for this
    * specific controller and opens a new Ext.window.Window
    * @return void
    */
   init: function() {
      // ...
   }
});</pre>
							<p>
								Jetzt steht die Grundstruktur einer Sub-Applikation, doch wie startet man diese jetzt? Genau f&uuml;r diesen Fall haben wir eine eigene <code>"Shopware.app.Application"</code>, die unter anderem das Laden von Sub-Applikationen anhand des kompletten <code>Namespaces</code> regelt und jeder Sub-Applikationen einen eigenen Event-Bus zur Verf&uuml;gung steht. &Ouml;ffnet zu erst ein mal die Konsole in eueren bevorzugten Browser und gebt folgendes ein:
							</p>
							
<pre class="prettyprint lang-js">Shopware.app.Application.addSubApplication({ name: 'Shopware.apps.Auth' });</pre>

							<p>
								Alternativ k&ouml;nnt ihr auch die Alias-Funktion <code>"openNewModule()"</code> verwenden, welche im globalen Scope abgelegt ist
							</p>
<pre class="prettyprint lang-js">openModule('Shopware.apps.Auth' );</pre>
						</div>
					</div>
				</section>  <!-- //Controller -->
				
				<!-- Store -->
				<section id="store">
					<div class="page-header">
						<h2>4. Store - die Datenverwaltung</h2>
					</div>
				
					<div class="row">
						<div class="span16">
							<p>
								Die Grundlage jedes Backend-Modul sind die Daten und die Kommunikation zum Server hin. ExtJS bietet hierf&uuml;r ausgezeichnete Komponenten an, die die komplette Kommunikation und Synchronisation &uuml;bernehmen - die sogenannten <code>"DataStores"</code>. Diese DataStores laufen in ExtJS 4 unter den Namespace <code>"Ext.data.*"</code>. Diese DataStores werden wir auch in unseren Modul verwenden. Legt dazu eine neue Datei names "main.js" im Verzeichnis "stores" an. Hier werden wir die Implementierung des Stores vornehmen.
							</p>
							
<pre class="prettyprint lang-js linenums">Ext.define('Shopware.apps.Auth.store.Main', {

   /**
    * Extend for the standard ExtJS 4 <a href="http://docs.sencha.com/ext-js/4-0/#!/api/Ext.data.Store" target="_blank">{@link Ext.data.Store}</a>
    * @string
    */
   extend: 'Ext.data.Store',
   
   /**
    * Auto load the store after the component
    * is initialized
    * @boolean 
    */
   autoLoad: true,
   
   /**
    * Amount of data loaded at once
    * @integer
    */
   pageSize: 30,
   
   /**
    * Define the used model for this store
    * @string
    */
   model : 'Shopware.apps.Auth.model.Main'
});</pre>
							
							<p>
								Als N&auml;chstes wechselt man in den <code>"Main"</code>-Controller und kommentiert das <code>"stores"</code>-Array wieder ein.
							</p>

<pre class="prettyprint lang-js linenums">...

/**
 * Required stores for controller
 * @array
 */
stores: [ 'Main' ]

...</pre>
						</div>
					</div>
				</section>  <!-- //Store -->
				
				<!-- Model -->
				<section id="model">
					<div class="page-header">
						<h2>5. Das Model</h2>
					</div>
				
					<div class="row">
						<div class="span16">
							<p>
								Im letzten Schritt haben wir den DataStore "Main" f&uuml;r die Sub-Applikation anlegen, doch woher wei&szlig; der Store welche Felder er erwarten kann und woher er &uuml;berhaupt die Daten erfragen soll? ExtJS verwendet f&uuml;r diese Angaben ein Model, welches diese Daten angibt und wo man zus&auml;tzlich seine Validierungsregeln einbauen kann. Um die Implemtierung des Model werden wir uns jetzt k&uuml;mmern, dazu legen wir zu aller erst eine neue Datei namens <code>"main.js"</code> im Verzeichnis "model" an. Im Fall der Sub-Applikation <code>"Shopware.apps.Auth"</code> sieht die Implementierung des Models wie folgt aus:
							</p>
							
<pre class="prettyprint lang-js linenums">Ext.define('Shopware.apps.Auth.model.Main', {

   /**
    * Extends the standard ExtJS 4 <a href="http://docs.sencha.com/ext-js/4-0/#!/api/Ext.data.Model" target="_blank">{@link Ext.data.Model}</a>
    * @string
    */
   extend: 'Ext.data.Model',
   
   /**
    * The fields used for this model
    * @array 
    */
   fields: ['id', 'username', 'password', 'lastlogin', 'name', 'email', 'active', 'admin', 'failedlogins' ],
   
   /**
    * Configure the data communication
    * @object
    */
   proxy: {
      type: 'ajax',
      
      /**
       * Configure the url mapping for the different
       * store operations based on <a href="http://de.wikipedia.org/wiki/CRUD" target="_blank">{@link CRUD}</a>
       * @object
       */
      api: {
         read: '{url controller="auth" action="getUsers"}',
         create: '{url controller="auth" action="createUser"}',
         update: '{url controller="auth" action="updateUser"}',
         destroy: '{url controller="auth" action="deleteUser"}'
      },
      
      /**
       * Configure the data reader
       * @object
       */
      reader: {
         type: 'json',
         root: 'data'
      }
   }
});</pre>

							<p>
								Als N&auml;chstes wechselt man in den <code>"Main"</code>-Controller und kommentiert das <code>"model"</code>-Array wieder ein.
							</p>

<pre class="prettyprint lang-js linenums">...

/**
 * Required models for controller
 * @array
 */
models: [ 'Main' ]

...</pre>
						</div>
					</div>
				</section>  <!-- //Model-->
				
				<!-- View -->
				<section id="view">
					<div class="page-header">
						<h2>6. View - die Anzeige</h2>
					</div>
				
					<div class="row">
						<div class="span4">
							<p>
								An dieser Stelle haben wir alle ben&ouml;tigten Daten zur Verf&uuml;gung, der Store wei&szlig; anhand des Models, welche Daten er erwartet und an welche URLs er die Datenoperationen senden soll. Jetzt ist es an der Zeit die bereitgestellten Daten in einen optisch ansprechen und benutzerfreundlichen Interface anzuzeigen und f&uuml;r den Benutzer die M&ouml;glichkeit zu schaffen mit dem Modul zu interagieren. Hierzu sind in ExtJS 4 Views vorgesehen.
							</p>
						</div>
						<div class="span12">
							<figure>
								<img src="img/screen_example-module.png" alt="Das fertige Modul" />
								<figcaption><code>Shopware.apps.Auth</code> - Endergebnis der View</figcaption>
							</figure>
						</div>
					</div>
					
					<div class="space"></div>
					
					<div class="row">
						<div class="span16">
							<p>
								ExtJS 4 bietet eine Vielzahl an Komponenten an, die f&uuml;r die Gestaltung des Interfaces genutzt werden k&ouml;nnen. Wir verwenden f&uuml;r die Darstellung der Daten das <code>"Ext.grid.Panel"</code>. Um mit der Implementierung der View zu beginnen muss zu erst die passende Datei angelegt werden. Das <code>"view"</code>-Verzeichnis hat eine Besonderheit gegen&uuml;ber dem <code>"controller"</code>-, <code>"model"</code>- oder <code>"store"</code>-Ordners. Der <code>"view"</code>-Ordner wird zus&auml;tzlich in die jeweiligen Controller der Sub-Applikation eingeteilt. Der Controller f&uuml;r das aktuelle <code>"Shopware.apps.Auth"</code>-Modul hei&szlig;t "Main", weshalb wir auch einen Ordner <code>"main"</code> im Verzeichnis <code>"view"</code> anlegen. 
							</p>
							
							<p>
								Im gerade erstellen Ordner <code>"main"</code> legen wir jetzt eine neue Datei namens "list.js" an. Diese Datei wird unser <code>"Ext.grid.Panel"</code> beinhalten. Bevor wir jedoch mit der Implementierung der View beginnen, kommentieren wir das <code>"views"</code>-Array im <code>"Main"</code>-Controller wieder ein.
							</p>

<pre class="prettyprint lang-js linenums">...

/**
 * Required views for controller
 * @array
 */
views: [ 'main.List' ]

...</pre>
						
							<p>
								Zus&auml;tzlich dazu erstellen wir ein neues <code>"Ext.window.Window"</code>, welches das GridPanel anzeigt. Hierf&uuml;r verwenden wir die <code>"init"</code>-Methode in Controller.
							</p>
							
<pre class="prettyprint lang-js linenums">/**
 * Creates the necessary event listener for this
 * specific controller and opens a new Ext.window.Window
 * @return void
 */
init: function() {
   Ext.create('Ext.window.Window', {
      layout: 'border',
      width: 800,
      height: 600,
      stateful: true,
      stateId: 'authUserList',
      title: 'Benutzerverwaltung',
      items: [ this.getView('main.List') ]
   }).show();
}</pre>

							<p>
								Bitte verwendet nicht die Eigenschaft <code>"autoShow"</code>, sondern ruft das Fenster per <code>"show()"</code> auf, da diese Eigenschaft nicht mit unseren angepassten Fenster zusammenarbeitet und bei der Initialisierung Javascript-Fehler verursacht. Bitte beachtet hier auch dass die View per <code>"this.getView('main.List')"</code> geladen wird. ExtJS 4 erstellt automatisch Getter und Setter f&uuml;r die jeweiligen Klassenattribute, welche auch genutzt werden sollten, da man so Probleme mit dem Scope / Geltungsbereich umgehen kann.
							</p>
							
							<div class="space"></div>
							
							<h4 id="basestructure">Das Grundger&uuml;st</h4>
							<p>
								Jetzt haben wir alle Voraussetzungen geschaffen um mit der Implementierung der View zu beginnen. Zu Beginn erstellen wir das Grundger&uuml;st unserer View, welches im Fall des aktuellen Moduls wie folgt ausssieht:
							</p>
							
<pre class="prettyprint lang-js linenums">Ext.define('Shopware.apps.Auth.view.main.List', {

   /**
    * Extend from the standard ExtJS 4 <a href="http://docs.sencha.com/ext-js/4-0/#!/api/Ext.grid.Panel" target="_blank">{@link Ext.grid.Panel}</a>
    * @string
    */
   extend: 'Ext.grid.Panel',
   
   /**
    * Alias name for the view. Could be used to get an instance
    * of the view through Ext.widget('userlist')
    * @string
    */
   alias: 'widget.userlist',
   
   /**
    * The window uses a border layout, so we need to set
    * a region for the grid panel
    * @string
    */
   region: 'center',
   
   /**
    * The view needs to be scrollable
    * @string
    */
   autoScroll: true,
   
   /**
    * Set the used store. You just need to set the store name
    * due to the fact that the store is defined in the same
    * namespace
    * @string
    */
   store: 'Main',
   
   /**
    * Sets up the ui component
    * @return void
    */
   initComponent: function() {
      // do something...
      
      this.callParent(arguments);
   }
});</pre>

							<h4>Die Spalten definieren</h4>
							
							<p>
								Aktuell ist das Grid so aber noch nicht nutzbar, da wir den GridPanel noch keine Spalten zugewiesen haben. Das GridPanel erwartet immer ein <code>"columns"</code>-Array, welches die jeweiligen Spalten beschreibt. Wir werden die Spalten in der <code>"initComponent"</code>-Methode implementieren.
							</p>
							
<pre class="prettyprint lang-js linenums">// Define the columns and renderers
this.columns = [
{
   header: 'Benutzername',
   dataIndex: 'username',
   flex: 1,
   renderer: this.nameColumn
}, {
   header: 'Name',
   dataIndex: 'name',
   flex: 1
}, {
   header: 'E-Mail Adresse',
   dataIndex: 'email',
   flex: 1,
   renderer: this.emailColumn
}, {
   header: 'Gruppe',
   dataIndex: 'admin',
   flex: 1,
   renderer: this.adminColumn
}, {

   /**
    * Special column type which provides
    * clickable icons in each row
    */
   xtype: 'actioncolumn',
   width: 50,
   items: [{
      iconCls: 'delete',
      action: 'delete',
      cls: 'delete',
      tooltip: 'L&ouml;scht diesen Benutzer',
   }, {
      iconCls: 'pencil',
      cls: 'editBtn',
      tooltip: 'Bearbeiten Sie diesen Benutzer'
   }]
}];</pre>

							<h4>Spaltenrenderer implementieren</h4>
							<p>
								Wenn Ihr jetzt das Modul aufruft, dann seht Ihr diverse Fehler in der Konsole. Dies liegt daran, dass die angegeben <code>Renderer</code> nicht implementiert wurden. Durch den Einsatz von <code>Renderer</code> k&ouml;nnen einzelne Spaltenfelder vor dem Rendern manipuliert werden um z.B. E-Mail Adresse mit einen mailto:-Link zu versehen. Bitte f&uuml;gt den folgenden Quelltext in die "list.js" ein, damit das Grid funktionsf&auml;hig ist.
							</p>
							
<pre class="prettyprint lang-js linenums">/**
 * Formats the name column
 *
 * @param [string] value
 * @return [string]
 */
nameColumn: function(value) {
   return Ext.String.format('{literal}<strong style="font-weight: 700">{0}</strong>{/literal}', value);
},

/**
 * Formats the email column
 *
 * @param [string] value
 * @return [string]
 */
emailColumn: function(value) {
   return Ext.String.format('{literal}<a href="mailto:{0}">{1}</a>{/literal}', value, value);
},

/**
 * Formats the admin (group) column
 *
 * @param [string] value
 * @return [string]
 */
adminColumn: function(value) {
   return (~~value === 1) ? 'Administrator' : 'Benutzer';
}</pre>
						</div>
					</div>
					
					<div class="row">
						<div class="span4">
							<p>Auf der Abbildung rechts (gelb markiert) sieht man das Grid in seiner jetzigen Form.</p>
							
							<p>Im n&auml;chsten Schritt werden wir die Checkbox-Spalte (rot markiert) einf&uuml;gen. Diese Spalte ist eine spezielle Form des Selection Models und zwar dem <code>"Ext.selection.CheckboxModel"</code> (<a href="http://docs.sencha.com/ext-js/4-0/#!/api/Ext.selection.CheckboxModel" target="_blank">Dokumentation</a>). Dieses SelectionModel werden wir wie auch schon die Spalten in der <code>"initComponent"</code>-Methode einbauen.
							</p>
						</div>
						
						<div class="span12">
							<img src="img/screen_example-module-grid.png" />
						</div>
					</div>
					
					<div class="row">
						<div class="span16">
<pre class="prettyprint lang-js linenums">this.selModel = Ext.create('Ext.selection.CheckboxModel');</pre>

							<h4>Gruppierung</h4>
							
							<p>
								Wie man auf den Screenshot sieht wurde eine Gruppierung eingebaut, die die Benutzer nach der jeweiligen Gruppe gruppiert. Diese Funktion wird &uuml;ber den Feature-Support von ExtJS 4 eingebaut. Features funktionieren &auml;hnlich wie Plugins wie sie bereits bekannt sind. Die Features, welche ExtJS 4 anbietet sind einfach nur eine weitere Komponente, die optional eingebaut werden kann. Das Features, welches wir f&uuml;r das Grid-Panel verwendet nennt sich <code>"Ext.grid.feature.Grouping"</code>(<a href="http://docs.sencha.com/ext-js/4-0/#!/api/Ext.grid.feature.Grouping" target="_blank">Dokumentation</a>) und wird im <code>"features"</code>-Array dem Grid-Panel zugewiesen. Zur Implementierung des Features verwenden wir wieder die <code>"initComponent"</code>-Methode
							</p>
							
<pre class="prettyprint lang-js linenums">// Row grouping
this.groupingFeature = Ext.create('Ext.grid.feature.Grouping', {
    groupHeaderTpl: '{literal}Gruppe: <tpl if="name == 1">Administrator</tpl><tpl if="name == 0">Benutzer</tpl> ({rows.length}){/literal}'
});
this.features = [ this.groupingFeature ];</pre>

							<h4>Paging Toolbar (unten)</h4>
							
							<p>
								Im n&auml;chsten Schritt werden wir eine Paging Toolbar einbauen, die in ExtJS unter dem Namespace <code>"Ext.toolbar.Paging"</code> (<a href="http://docs.sencha.com/ext-js/4-0/#!/api/Ext.toolbar.Paging" target="_blank">Dokumentation</a>) l&auml;uft, einbauen. Eine PagingToolbar bietet den	Vorteil, dass der Benutzer auf einen Blick sieht wie viele Seiten und Elemente im Grid sind sowie bietet Sie einen Geschwindigkeitszuwachs, da nicht alle Datens&auml;tze auf einmal bzw. bei der Initialisierung geladen werden m&uuml;ssen.
							</p>
							
							<p>
								Bei Einbau ist darauf zu achten, dass man im Store eine <code>"pageSize"</code> angeben hat. Diese Eigenschaft gibt wieder wie viele Datens&auml;tze auf einmal geladen werden sollen. Die <code>"pageSize"</code> wurde von uns im Store schon definiert, weshalb wir dies hier nicht mehr machen m&uuml;ssen.
							</p>
							
							<p>
								Wir m&uuml;ssen nur noch die Toolbar im GridPanel einbauen. Wir verwenden dazu dass <code>"dockedItems"</code>-Array, welches es erm&ouml;glicht bestimmte Elemente an festgelegten Stellen einzuf&uuml;hren.
							</p>
							
<pre class="prettyprint lang-js linenums">// Add paging toolbar to the bottom of the grid panel
dockedItems: [{
   dock: 'bottom',
   xtype: 'pagingtoolbar',
   displayInfo: true,
   store: 'Main'
}]</pre>
							<p>
								Um Probleme durch doppelte Toolbars bei mehreren Instanzen des Moduls zu unterbinden sollte man unter der Angabe <code>this.callParent(arguments);</code> folgendes Code-Snippet einf&uuml;gen, welches daf&uuml;r sorgt, dass das <code>"dockedItems"</code>-Array dupliziert und neu zugewiesen wird.
							</p>
<pre class="prettyprint lang-js">this.dockedItems = Ext.clone(this.dockedItems);</pre>

							<h4>Button Toolbar (oben)</h4>
							
							<p>
								Langsam aber sicher n&auml;hern wir uns der Fertigstellung des Interfaces f&uuml; unser <code>"Shopware.apps.Auth"</code>-Modul. Was jetzt noch fehlt sind weitere Interaktionselemente, wo mit der Benutzer das Modul bearbeiten kann. F&uuml;r dieses Modul habe ich mich f&uuml;r eine Toolbar entschieden, die &uuml;ber den Grid erscheinen soll. Hierzu verwenden wir die <code>"Ext.toolbar.Toolbar"</code> (<a href="http://docs.sencha.com/ext-js/4-0/#!/api/Ext.toolbar.Toolbar" target="_blank">Dokumentation</a>), die wir als <code>"dock: 'top'"</code> definieren und dem <code>"dockedItems"</code>-Array zuweisen.
							</p>

<pre class="prettyprint lang-js linenums">this.toolbar = Ext.create('Ext.toolbar.Toolbar', {
   dock: 'top',
    items: [{
      iconCls: 'add',
      text: 'Hinzuf&uuml;gen',
      action: 'add'
   }, {
      iconCls: 'delete',
      text: 'Markierte Eintr&auml;ge l&ouml;schen',
      disabled: true,
      action: 'deleteUsers'
   }]
});</pre>

							<p>
								Wichtig bei der Zuweisung der Toolbar ist, dass diese erst nach dem Duplizieren des <code>"dockedItems"</code>-Array zugewiesen wird.
							</p>
							
<pre class="prettyprint lang-js linenums">this.dockedItems = Ext.clone(this.dockedItems);
this.dockedItems.push(this.toolbar);</pre>

							<p>
								Wie Ihr sicherlich bemerkt habt, werden keine <code>"handler"</code> in der Toolbar gemacht. Die Adressierung der jeweiligen Buttons l&auml;ft hier &uuml;ber die <code>"action"</code>-Eigenschaft. Diese kann im Controller &uuml;ber die <code>"Ext.ComponentQuery"</code>-Komponente (<a href="http://docs.sencha.com/ext-js/4-0/#!/api/Ext.ComponentQuery" target="_blank">Dokumentation</a>) angesprochen werden.
							</p>
							
							<h4>Implementierung der Checkbox-Spalte</h4>
							
							<p>
								Wir haben an dieser Stelle das Interface abgeschlossen und k&ouml;nnen jetzt mit der Implementierung der Event-Handler beginnen. Wie bereits mehrfach erw&auml;hnt werden die Events im Controller definiert und die Callback-Funktion hinterlegt. Es gibt hier aber Ausnahmen, wenn Events nur UI relevante Dinge wie z.B. das Freischalten eines Buttons &uuml;bernehmen. So ist es auch im Falle der Checkbox-Spalte. Hier soll bei jedem Klicken auf eine Checkbox gepr&uuml;ft werden, ob ein bzw. mehrere Eintr&auml;ge angehakt sind und soll dann den Button "Markierte Eintr&auml;ge l&ouml;schen" (<code>"action"</code> = deleteUsers) freischalten.
							</p>
							
							<div class="space"></div>
							
							<p>
								Um dieses Ziel zu erreichen setzen wir einen Listener auf <code>"SelectionModel"</code>. Die Implementierung sollte wie folgt aussehen:
							</p>
							
<pre class="prettyprint lang-js linenums">this.selModel = Ext.create('Ext.selection.CheckboxModel', {
   listeners: {
      // Unlocks the save button if the user has checked at least one checkbox
      selectionchange: function(sm, selections) {
         var owner = this.view.ownerCt,
            btn = owner.down('button[action=deleteUsers]')

         btn.setDisabled(selections.length == 0);
      }
   }
});</pre>
						</div>
					</div>
				</section>  <!-- //View -->
				
				<!-- Events -->
				<section id="events">
					<div class="page-header">
						<h2>Events</h2>
					</div>
				
					<div class="row">
						<div class="span-16">
							<p>
								In diesen Abschnitt des Tutorials werden wir uns um das Event-Binding im Controller k&uuml;mmern. Dazu wechseln wir in den <code>"Main"</code>-Controller, der sich unter <strong>"/templates/_default/backend/auth/controller/main.js"</strong> befindet. Hier finden wir die <code>"init"</code>-Methode, die nach der Initialisierung des Controllers aufgerufen wird. An dieser Stelle haben wir die M&ouml;glichkeit &uuml;ber die Methode <code>"this.control"</code> (<a href="http://docs.sencha.com/ext-js/4-0/#!/api/Ext.app.Controller-method-control" target="_blank">Dokumentation</a>) Events zu binden. Die Adressierung l&auml;ft hier &uuml;ber den <code>"alias"</code>-Eigenschaft im Controller (<em>"widget.userlist"</em>) und der jeweiligen <code>"action"</code>-Eigenschaft des Buttons. In unseren Fall m&ouml;chte ich gerne beim Rendern des GridPanels eine Konsolen-Ausgabe erzeugen und beim Klicken auf den Hinzu&uuml;gen-Button soll eine Alert-Meldung erscheinen.
							</p>
							
<pre class="prettyprint lang-js linenums">init: function() {
   var me = this;
   
   me.control({
      'userlist': {
         render: function() {
            console.log('Userlist is rendered !!!');
         }
      },
      'userlist button[action=add]': {
         click: me.onCreateUser
      }
   });
   
   //... create Ext.window.Window
   
   this.callParent(arguments)
}</pre>

							<p>
								Im oben aufgef&uuml;hrten Beispiel wurden jetzt zwei Event-Listener definiert. Der erste Listener befindet sich auf den Gridpanel (<em>"userlist"</em>), hier wird bei <code>"render"</code>, die angegebene Callback-Funktion ausgef&uuml;hrt, die eine Logmeldung in der Konsole generiert.
							</p>
							
							<div class="space"></div>
							
							<p>
								Zum anderen wurde ein weitere Event-Listener gesetzt, der auf das <code>"click"</code>-Event des Hinzuf&uuml;gen-Buttons (action = <code>"add"</code>) die Callback-Methode <code>"onCreateUser"</code> aufruft, die wir im n&auml;chsten Schritt implementieren wollen.
							</p>
							
							<div class="space"></div>
							
							<p>
								Wir legen dazu im <code>"Main"</code>-Controller eine neue Methode mit dem Namen <code>"onCreateUser"</code> an. Da der Button in ExtJS 4 unter dem Namespace <code>"Ext.button.Button"</code> (<a href="http://docs.sencha.com/ext-js/4-0/#!/api/Ext.button.Button" target="_blank">Dokumentation</a>) l&auml;ft, schauen wir hier in der Dokumenation nach, welche Parameter beim <code>"click"</code>-Event an die Callback-Methode gegeben werden. Im Falle des Buttons sind dass folgende Parameter
							</p>
							
							<ol>
								<li>this : Ext.button.Button</li>
								<li>e : Event - The click event</li>
								<li>eOpts : Object - The options object passed to Ext.util.Observable.addListener.</li>
							</ol>
							
							<p>Daraus resultiert folgender Methode:</p>
							
<pre class="prettyprint lang-js linenums">/**
 * Opens the Ext.window.window which displays
 * the Ext.form.Panel to create a new user
 *
 * @param [object] btn - Ext.button.Button
 * @param [object] event - Passed event object
 * @param [object] opts - Additional parameter object
 * @return void
 */
onCreateUser: function(btn, event, opts) {
   alert(btn.text + ' was clicked !!!');
}</pre>
						</div>
					</div>
				</section>  <!-- //Events-->
				
				<!-- Source  -->
				<section id="source">
					<div class="page-header">
						<h2>Source-Code</h2>
					</div>
				
					<div class="row">
						<div class="span16">
							<h4>Main-Controller</h4>
<pre class="prettyprint lang-js linenums">Ext.define('Shopware.apps.Auth.controller.Main', {

   /**
    * Extend from the standard ExtJS 4  <a href="http://docs.sencha.com/ext-js/4-0/#!/api/Ext.app.Controller" target="_blank">{@link Ext.app.Controller}</a>
    * @string
    */
   extend: 'Ext.app.Controller',
   
   /**
    * Required views for controller
    * @array
    */
   views: [ 'main.List' ],
   
   /**
    * Required stores for controller
    * @array
    */
   stores: [ 'Main' ],
   
   /**
    * Required models for controller
    * @array
    */
   models: [ 'Main' ]
   
   /**
    * Creates the necessary event listener for this
    * specific controller and opens a new Ext.window.Window
    * @return void
    */
   init: function() {
      var me = this;
      
      me.control({
         'userlist': {
            render: function() {
               console.log('Userlist is rendered !!!');
            }
         },
         'userlist button[action=add]': {
            click: me.onCreateUser
         }
      });
      
      Ext.create('Ext.window.Window', {
        layout: 'border',
        width: 800,
        height: 600,
        title: 'Benutzerverwaltung',
        items: [ me.getView('main.List') ]
      }).show();
   
      me.callParent(arguments);
   },
   
   /**
    * Opens the Ext.window.window which displays
    * the Ext.form.Panel to create a new user
    *
    * @param [object] btn - Ext.button.Button
    * @param [object] event - Passed event object
    * @param [object] opts - Additional parameter object
    * @return void
    */
   onCreateUser: function(btn, event, opts) {
      alert(btn.text + ' was clicked !!!');
   }
});</pre>

							<h4>Main-Model</h4>
							
<pre class="prettyprint lang-js linenums">Ext.define('Shopware.apps.Auth.model.Main', {

   /**
    * Extends the standard ExtJS 4 <a href="http://docs.sencha.com/ext-js/4-0/#!/api/Ext.data.Model" target="_blank">{@link Ext.data.Model}</a>
    * @string
    */
   extend: 'Ext.data.Model',
   
   /**
    * The fields used for this model
    * @array 
    */
   fields: ['id', 'username', 'password', 'lastlogin', 'name', 'email', 'active', 'admin', 'failedlogins' ],
   
   /**
    * Configure the data communication
    * @object
    */
   proxy: {
      type: 'ajax',
      
      /**
       * Configure the url mapping for the different
       * store operations based on <a href="http://de.wikipedia.org/wiki/CRUD" target="_blank">{@link CRUD}</a>
       * @object
       */
      api: {
         read: '{url controller="auth" action="getUsers"}',
         create: '{url controller="auth" action="createUser"}',
         update: '{url controller="auth" action="updateUser"}',
         destroy: '{url controller="auth" action="deleteUser"}'
      },
      
      /**
       * Configure the data reader
       * @object
       */
      reader: {
         type: 'json',
         root: 'data'
      }
   }
});</pre>

							<h4>Main-Store</h4>
							
<pre class="prettyprint lang-js linenums">Ext.define('Shopware.apps.Auth.store.Main', {

   /**
    * Extend for the standard ExtJS 4 <a href="http://docs.sencha.com/ext-js/4-0/#!/api/Ext.data.Store" target="_blank">{@link Ext.data.Store}</a>
    * @string
    */
   extend: 'Ext.data.Store',
   
   /**
    * Auto load the store after the component
    * is initialized
    * @boolean 
    */
   autoLoad: true,
   
   /**
    * Amount of data loaded at once
    * @integer
    */
   pageSize: 30,
   
   /**
    * Define the used model for this store
    * @string
    */
   model : 'Shopware.apps.Auth.model.Main'
});</pre>

							<h4>List-View</h4>
							
<pre class="prettyprint lang-js linenums">/**
 * Shopware Backend - Auth Main List View
 *
 * @author st.pohl <stp@shopware.de>
 * @date 2012-01-04
 * @category backend
 * @package auth
 * @subpackage view
 */
Ext.define('Shopware.apps.Auth.view.main.List', {
   extend: 'Ext.grid.Panel',
   alias: 'widget.userlist',
   region: 'center',
   autoScroll: true,
   store: 'Main',

   // Add paging toolbar to the bottom toolbar
   dockedItems: [{
      dock: 'bottom',
      xtype: 'pagingtoolbar',
      displayInfo: true,
      store: 'Main'
   }],

    /**
     * Initialize the view components
     *
     * @return void
     */
   initComponent: function() {
      var me = this;

        this.selModel = Ext.create('Ext.selection.CheckboxModel', {
            listeners: {
                // Unlocks the save button if the user has checked at least one checkbox
                selectionchange: function(sm, selections) {
                    var owner = this.view.ownerCt,
                        btn = owner.down('button[action=deleteUsers]')

                    btn.setDisabled(selections.length == 0);
                }
            }
        });

      // Define the columns and renderers
      this.columns = [
      {
         header: 'Benutzername',
         dataIndex: 'username',
         flex: 1,
         renderer: this.nameColumn
      }, {
         header: 'Name',
         dataIndex: 'name',
         flex: 1
      }, {
         header: 'E-Mail Adresse',
         dataIndex: 'email',
         flex: 1,
         renderer: this.emailColumn
      }, {
         header: 'Gruppe',
         dataIndex: 'admin',
         flex: 1,
         renderer: this.adminColumn
      }];

      // Row grouping
      this.groupingFeature = Ext.create('Ext.grid.feature.Grouping', {
          groupHeaderTpl: '{literal}Gruppe: <tpl if="name == 1">Administrator</tpl><tpl if="name == 0">Benutzer</tpl> ({rows.length}){/literal}'
      });
      this.features = [ this.groupingFeature ];

      // Toolbar
      this.toolbar = Ext.create('Ext.toolbar.Toolbar', {
         dock: 'top',
          items: [{
            iconCls: 'add',
            text: 'Hinzufügen',
            action: 'add'
         }, {
            iconCls: 'delete',
            text: 'Markierte Einträge löschen',
            disabled: true,
            action: 'deleteUsers'
         }]
      });

      this.dockedItems = Ext.clone(this.dockedItems);
      this.dockedItems.push(this.toolbar);

      this.callParent();
   },

   /**
    * Formats the name column
     *
    * @param [string] value
     * @return [string]
    */
   nameColumn: function(value) {
      return Ext.String.format('{literal}<strong style="font-weight: 700">{0}</strong>{/literal}', value);
   },

   /**
    * Formats the email column
     *
    * @param [string] value
     * @return [string]
    */
   emailColumn: function(value) {
      return Ext.String.format('{literal}<a href="mailto:{0}">{1}</a>{/literal}', value, value);
   },

   /**
    * Formats the admin (group) column
     *
    * @param [string] value
     * @return [string]
    */
   adminColumn: function(value) {
      return (~~value === 1) ? 'Administrator' : 'Benutzer';
   }
});</pre>

						</div>
					</div>
				</section>  <!-- //source-->
				
				<!-- Pitfalls -->
				<section id="pitfalls">
					<div class="page-header">
						<h2>Pitfalls - Bekannte Stolpersteiner</h2>
					</div>
				
					<div class="row">
						<div class="span16">
							<ol>
								<li>
									<h4>this.callParent() und this.callOverridden()</h4>
									
									<p>
										Bitte achtet bei der Benutzung der Funktionen this.callParent() und  this.callOverridden() darauf, dass ihr als Parameter immer <code>"arguments"</code> statt <code>"this"</code> &uuml;bergibt, da sonst das Modul nicht lauff&auml;hig im Google Chrome ist.
									</p>
									
<pre class="prettyprint lang-js linenums">initComponent: function() {
   // to something
   
   this.callParent(arguments);
}
</pre>
								</li>
							</ol>
						</div>
					</div>
				</section>  <!-- //Pitfalls-->
				
		</div><!-- //Container -->	
		
		<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
		<script type="text/javascript" src="js/prettify.js"></script>
		<script type="text/javascript" src="js/jquery.checklist.js"></script>
		<script>$(function () { prettyPrint() })</script>
	</body>
</html>